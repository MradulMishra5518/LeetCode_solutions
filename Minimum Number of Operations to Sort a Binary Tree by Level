class Solution {
public:
    int minswap(vector<int> v) {
        vector<int> temp(v.begin(),v.end());
        sort(temp.begin(), temp.end());

        unordered_map<int,int> mp;
        for(int i=0 ; i<v.size() ; i++) {
            mp[v[i]]=i;
        }

        int cnt=0;

        for(int i=0 ; i<v.size() ; i++) {
            if(v[i]!=temp[i]) {
                cnt++;
                int idx= mp[temp[i]];
                mp[v[i]]=idx;
                swap(v[i],v[mp[temp[i]]]);
            }
        }
        return cnt;
    }

    int minimumOperations(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);

        int ans=0;
        while(!q.empty()){
            int n=q.size();
            vector<int> temp;
            while(n--) {
                TreeNode *it=q.front();
                q.pop();
                temp.push_back(it->val);
                if(it->left) q.push(it->left);

                if(it->right) q.push(it->right);
            }
            ans+=minswap(temp);
        }
        return ans;
    }
};
